{
  "language": "Solidity",
  "sources": {
    "contracts/AadhaarVoting.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ncontract AadhaarVoting {\n    address public admin;\n\n    constructor() {\n        admin = msg.sender;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Only admin can perform this\");\n        _;\n    }\n\n    enum ElectionType { General, State }\n\n    struct Election {\n        string name;\n        string state; // Empty for general election\n        uint256 startTime;\n        uint256 endTime;\n        uint256 year;\n        bool isActive;\n        address[] candidates;\n        mapping(address => uint256) votes;\n        mapping(address => bool) hasVoted;\n        mapping(address => bool) isValidCandidate;\n    }\n\n    // A helper struct without mappings for safe return\n    struct ElectionDetails {\n        bytes32 electionId;\n        string name;\n        string state;\n        uint256 startTime;\n        uint256 endTime;\n        uint256 year;\n        bool isActive;\n        address[] candidates;\n    }\n\n\n    mapping(address => bool) public voters;\n    mapping(bytes32 => Election) public elections;\n\n    bytes32[] public generalElectionIds;\n    bytes32[] public stateElectionIds;\n\n    event ElectionCreated(bytes32 indexed electionId);\n\n    // === Voter Management ===\n    function addVoter(address _voter) public onlyAdmin {\n        voters[_voter] = true;\n    }\n\n    function isEligible(address _voter) public view returns (bool) {\n        return voters[_voter];\n    }\n\n    // === Candidate Management ===\n    function addCandidate(bytes32 _electionId, address _candidate) public onlyAdmin {\n        Election storage election = elections[_electionId];\n        \n        require(election.isActive, \"Election not active\");\n        require(!election.isValidCandidate[_candidate], \"Candidate already added\");\n\n        election.candidates.push(_candidate);\n        // election.votes[_candidate] = 0;\n        election.isValidCandidate[_candidate] = true;\n    }\n\n\n    // === Election ID Generator ===\n    function getElectionId(\n        string memory _name,\n        ElectionType _type,\n        string memory _state,\n        uint256 _year\n    ) internal view returns (bytes32) {\n        return keccak256(abi.encodePacked(_name, _type, _state, _year, block.timestamp));\n    }\n\n    // === Create Election ===\n    function createElection(\n        string memory _name,\n        string memory _state, // Pass \"\" for general election\n        address[] memory _candidates,\n        uint256 _startTime,\n        uint256 _endTime,\n        uint256 _year,\n        ElectionType _type\n    ) public onlyAdmin returns (bytes32) {\n        require(_startTime < _endTime, \"Invalid election time\");\n\n        bytes32 electionId = getElectionId(_name, _type, _state, _year);\n\n        Election storage election = elections[electionId];\n        election.name = _name;\n        election.state = _state;\n        election.startTime = _startTime;\n        election.endTime = _endTime;\n        election.year = _year;\n        election.isActive = true;\n        \n        for (uint i = 0; i < _candidates.length; i++) {\n            address candidate = _candidates[i];\n            election.candidates.push(candidate);\n            election.isValidCandidate[candidate] = true;\n        }\n\n\n        if (_type == ElectionType.General) {\n            generalElectionIds.push(electionId);\n        } else {\n            stateElectionIds.push(electionId);\n        }\n\n        emit ElectionCreated(electionId);\n\n        return electionId;\n    }\n\n    // === Vote ===\n    function voteElection(bytes32 _electionId, address _candidate) public {\n        require(voters[msg.sender], \"Not eligible\");\n\n        Election storage election = elections[_electionId];\n        require(election.isActive, \"Election not active\");\n        require(block.timestamp >= election.startTime && block.timestamp <= election.endTime, \"Election not running\");\n\n        // Cache storage reference\n        mapping(address => bool) storage hasVoted = election.hasVoted;\n        mapping(address => bool) storage isValidCandidate = election.isValidCandidate;\n\n        require(!hasVoted[msg.sender], \"Already voted\");\n        require(isValidCandidate[_candidate], \"Invalid candidate\");\n\n        hasVoted[msg.sender] = true;\n        election.votes[_candidate]++;\n\n    }\n\n    // Votes of Candidate in particular Election\n    function getAllVotes(bytes32 _electionId) public view returns (address[] memory, uint256[] memory) {\n        Election storage election = elections[_electionId];\n        uint256 candidatesCount = election.candidates.length;\n        \n        address[] memory candidateList = new address[](candidatesCount);\n        uint256[] memory voteCounts = new uint256[](candidatesCount);\n        \n        for (uint256 i = 0; i < candidatesCount; i++) {\n            candidateList[i] = election.candidates[i];\n            voteCounts[i] = election.votes[election.candidates[i]];\n        }\n        \n        return (candidateList, voteCounts);\n    }\n\n\n    // === Election Winner ===\n    function getElectionWinner(bytes32 _electionId) public view returns (address winner, uint256 highestVotes) {\n        Election storage election = elections[_electionId];\n        require(election.candidates.length > 0, \"No candidates found\");\n\n        uint256 maxVotes = 0;\n        address topCandidate;\n\n        for (uint256 i = 0; i < election.candidates.length; i++) {\n            address candidate = election.candidates[i];\n            uint256 votes = election.votes[candidate];\n\n            if (votes > maxVotes) {\n                maxVotes = votes;\n                topCandidate = candidate;\n            }\n        }\n\n        return (topCandidate, maxVotes);\n    }\n\n    // Election Winner (if tie is there)\n    function getElectionWinners(bytes32 _electionId) public view returns (address[] memory, uint256) {\n        Election storage election = elections[_electionId];\n        uint256 candidatesLength = election.candidates.length;\n\n        require(candidatesLength > 0, \"No candidates found\");\n\n        address[] memory tempWinners = new address[](candidatesLength);\n        uint256 maxVotes = 0;\n        uint256 winnerCount = 0;\n\n        for (uint256 i = 0; i < candidatesLength; i++) {\n            address candidate = election.candidates[i];\n            uint256 votes = election.votes[candidate];\n\n            if (votes > maxVotes) {\n                maxVotes = votes;\n                winnerCount = 1;\n                tempWinners[0] = candidate;\n            } else if (votes == maxVotes) {\n                tempWinners[winnerCount] = candidate;\n                winnerCount++;\n            }\n        }\n\n        address[] memory winners = new address[](winnerCount);\n        for (uint256 i = 0; i < winnerCount; i++) {\n            winners[i] = tempWinners[i];\n        }\n\n        return (winners, maxVotes);\n    }\n\n    // Get Election Details\n    function _getElectionDetails(bytes32[] storage electionIds) internal view returns (ElectionDetails[] memory) {\n        uint256 count = electionIds.length;\n        ElectionDetails[] memory details = new ElectionDetails[](count);\n\n        for (uint256 i = 0; i < count; i++) {\n            bytes32 electionId = electionIds[i];\n            Election storage e = elections[electionId];\n\n            details[i] = ElectionDetails({\n                electionId: electionId,\n                name: e.name,\n                state: e.state,\n                startTime: e.startTime,\n                endTime: e.endTime,\n                year: e.year,\n                isActive: e.isActive,\n                candidates: e.candidates\n            });\n        }\n\n        return details;\n    }\n\n    function getGeneralElectionDetails() public view returns (ElectionDetails[] memory) {\n        return _getElectionDetails(generalElectionIds);\n    }\n\n    function getStateElectionDetails() public view returns (ElectionDetails[] memory) {\n        return _getElectionDetails(stateElectionIds);\n    }\n\n\n\n\n    // === Getters ===\n    function getCandidateVotes(bytes32 _electionId, address _candidate) public view returns (uint256) {\n        return elections[_electionId].votes[_candidate];\n    }\n\n    function userHasVoted(bytes32 _electionId, address _voter) public view returns (bool) {\n        return elections[_electionId].hasVoted[_voter];\n    }\n\n    function getElectionCandidates(bytes32 _electionId) public view returns (address[] memory) {\n        return elections[_electionId].candidates;\n    }\n\n    function getGeneralElectionIds() public view returns (bytes32[] memory) {\n        return generalElectionIds;\n    }\n\n    function getStateElectionIds() public view returns (bytes32[] memory) {\n        return stateElectionIds;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}